<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.8.0/lib/p5.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://kit.fontawesome.com/8e4c4e5f94.js" crossorigin="anonymous"></script>
    <script type="text/javascript" src="./ressources.js"></script>
    <script type="text/javascript" src="./controlers.js"></script>
    <script type="text/javascript" src="./class.js"></script>
  </head>

  <style type="text/css">

    @font-face {
        font-family: NeueKabel;
        src: url("fonts/NeueKabel.otf") format("opentype");
    }    

    @font-face {
        font-family: NeueKabel;
        font-weight: bold;
        src: url("fonts/NeueKabel-Bold.otf") format("opentype");
    }

    .container {
      display: flex;
      height: 95vh;
      font-family: NeueKabel, sans-serif;
    }

    /* buttons */

    .button {
      background-color: white;
      border: 1.5px solid #261D11;
      cursor: pointer;   
    }

    .button:hover {
      background-color: #261D11;
      color: white;
    }  

    .button-clicked {
      background-color: #261D11;
      color: white;
    }

    .btn-top {
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
    }  

    .title {
      margin-bottom: 10px;
    }      

    .dashboard {
      width: 3%;
      height: 95vh;
    }

    .dashboard-legend {
      font-size: 18px;
      text-align: center;
      margin-bottom: 5px;
    }

    .logo {
      display: flex;
      justify-content: center;      
      width : 90%
    }
    
    .canvas {
      flex-grow: 1;
      margin : auto;
      height: 95vh;
    }

    .footer {
      margin-left: 3%;
      margin-top: 10px;
      font-size: 12px;
      font-weight: bold;
      font-family: NeueKabel, sans-serif;
    }

    .tooltip {
      position: relative;
      display: inline-block;
    }    

    /* Tooltip text */
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 120px;
      background-color: #261D11;
      color: #fff;
      border: 2px solid #fff;
      text-align: left;
      padding: 5px 0;
      padding-left: 10px;
     
      position: absolute;
      left: 30px;
      top: -4px;
      z-index: 1;
    }

    .tooltip:hover .tooltiptext {
      visibility: visible;
    }    


  </style>

  <body>
    <main> 
      <div class="container">
        <div class="dashboard">
          <!-- title -->
          <img src = "./logo.svg" class="logo" alt="Chronoblox"/>
          
          <!-- night / day mode -->
          <p class="dashboard-legend">mode</p>
          <div class="btn-top">
            <!-- night -->
            <button onclick="setShader('night')" class="button" id="nightshader">
              <i class="fa-solid fa-moon"></i>
            </button>            
          </div>           
          <div class="btn-top">
            <!-- day -->
            <button onclick="setShader('day')" class="button" id="dayshader">
              <i class="fa-solid fa-sun"></i>
            </button>            
          </div>           

          <!-- layers -->
          <p class="dashboard-legend">layers</p>
          <div class="btn-top">
            <!-- display canopy -->
            <button onclick="removeCanopy()" class="button button-clicked" id="btncanopy">
              <i class="fa-solid fa-layer-group"></i>
            </button>            
          </div>           
          <div class="btn-top">
            <!-- display edges -->
            <button onclick="removeEdges()" class="button button-clicked" id="btnedges">
              <i class="fa-solid fa-circle-nodes"></i>
            </button>            
          </div> 
          <div class="btn-top">
            <!-- display metadata -->
            <button onclick="removeMeta()" class="button tooltip" id="btnmeta">
              <i class="fa-solid fa-circle-question"></i>
              <span class="tooltiptext" id="metalegend" ></span>
            </button>            
          </div>
          <div class="btn-top">
            <!-- display tales -->
            <button onclick="removeTales()" class="button" id="btntales">
              <i class="fa-solid fa-bars-staggered"></i>
            </button>            
          </div>                    
        </div> 
        <div class="canvas" id="p5canvas"></div>    
      </div>
      <div class="footer"></div> 
    </main>
  </body>
  <script type="text/javascript">

    p5.disableFriendlyErrors = true;

    // fonts
    let neuekabel,neuekabelbold;

    // interactions
    let focus = 0;
    let shader = "night";

    // shared elements
    let nodesScale;
    let meta_data = {};

    // Canopy
    let canopyHulls_seman = {};
    let canopyHulls_socio = {};    
    let displayCanopy = true;

    // Chronoblocks
    let chronoNodes_seman = {}, chronoSyncEdges_seman = [];
    let chronoNodes_socio = {}, chronoSyncEdges_socio = [];    
    let socio_to_chronoNodes_socio = {}, seman_to_chronoNodes_seman = {};
    let displayMeta = false;
    let displayEdges = true;
    let chronoSyncEdgesScale;
    let metaColorScale;

    // Tales
    const talesColorScale = d3.scaleOrdinal(d3.schemeSet3);
    let talesEdges_seman = {}, talesNodes_seman = {};
    let talesEdges_socio = {}, talesNodes_socio = {};    
    let talesEdgesScale;
    let displayTales = false;
    let currentTale = -2;
    let clickedNodeSource = '', clickedNodeTarget = [], clickedRealm = '', clickedNodeSourceAtoms = []; 

    // raw data elements
    let nodes_seman, edges_seman;
    let nodes_socio, edges_socio;
    let periods = [];

    // canvas elements
    let w = document.getElementById("p5canvas").offsetWidth,
        h = document.getElementById("p5canvas").offsetHeight;   
    let y0_socio = 0,
        y0_time  = 5*h/11,
        y0_seman = 6*h/11;
    let h_socio  = 5*h/11,
        h_time   = h/11, 
        h_seman  = 5*h/11;

    function sumFlowByPeriod() {
      let flowByPeriod = periods.map((period) => {
        let blocks = nodes.findRows(period,'phase'); 
        let sum = blocks.reduce((acc,b) => {
          return acc + parseInt((nodes.findRow(b.get('id'),'id')).get('size'))
        },0)
        return sum        
      })      
      return flowByPeriod
    }

    function getLimits(key,table,predicate) {
      let inf = Number.MAX_VALUE, sup = Number.MIN_VALUE;
      (table.getRows()).forEach((row) => {
        if (predicate != null) {
          // add an extra filter if needed
          let predicate_key = Object.keys(predicate)[0];
          if (row.get(predicate_key) != predicate[predicate_key]) {
            return;
          }
        }
        let v = parseFloat(row.get(key))
        if (v > sup) {
          sup = v
        }
        if (v < inf) {
          inf = v
        }        
      })
      return [inf,sup];
    }

    function zip(keys, values) {
        let acc = {};
        for (let i = 0; i < keys.length; i++) {
            acc[keys[i]] = values[i];
        }
        return acc;
    } 

    function flatten(arr) {
      let tmp = arr.reduce((acc,cur) => acc.concat(cur), []);
      return [...new Set(tmp)]
    }


    function getNeighbours(id,period) {
      let neighbours = raw_sync_edges
            .findRows(period, 'period_int')
            .filter((edge) => ( (edge.get('source') == id) || (edge.get('target') == id)) 
                             && (edge.get('source') != edge.get('target')))
      return neighbours      
    } 

    function getNextPeriod(prd) {
      let idx = periods.indexOf(prd)
      return periods[idx + 1]
    }

    function getDegree(id,period) {
      let neighbours = getNeighbours(id,period)
      return neighbours.length
    }

    function getStrength(id,period) {
      let neighbours = getNeighbours(id,period)
      return (neighbours.map((e) => parseFloat(e.get('weight')))).reduce((acc,cur) => acc + cur,0)
    } 

    function preload() {
      
      nodes_socio = loadTable('../layout/web-archives_co-authors_blocks.csv','csv','header')
      edges_socio = loadTable('../layout/web-archives_co-authors_edges.csv','csv','header')  

      nodes_seman = loadTable('../layout/web-archives_co-words_blocks.csv','csv','header')
      edges_seman = loadTable('../layout/web-archives_co-words_edges.csv','csv','header')    
      
      neuekabel = loadFont('fonts/NeueKabel.otf');
      neuekabelbold = loadFont('fonts/NeueKabel-Bold.otf');

      setShader("night")
    }

    function setupChronoElements(realm,nodes,edges) {

      let fromLeftToRight = true;

      function toXScreen(x) {
        if (fromLeftToRight) {
          return map(x, xLimitsChrono[0] - 1, xLimitsChrono[1] + 1, 0, w);
        } else {
          return map(x, xLimitsChrono[0] - 1, xLimitsChrono[1] + 1, w, 0);
        }  
      }

      function toYScreen(y) {
        return map(y, yLimitsChrono[0] - 1, yLimitsChrono[1] + 1, 0, h_socio);
      }  

      function setupReadingDirection() {
        let xs_fst = nodes.findRows(periods[0],'phase').map((block) => parseFloat(block.get('x')));
        let xs_lst = nodes.findRows(periods[periods.length-1],'phase').map((block) => parseFloat(block.get('x')));      
        if ((min(xs_fst) < max(xs_lst)) && (max(xs_fst) < max(xs_lst))) {
          fromLeftToRight = true
        } else {
          fromLeftToRight = false
        } 
      }                  

      xLimitsChrono = getLimits('x',nodes)
      yLimitsChrono = getLimits('y',nodes) 

      // raw data to edges / nodes data

      raw_diac_edges = edges.findRows('diac', 'type')
      raw_sync_edges = edges.findRows('sync', 'type')

      diac_edges_limits = getLimits('weight',edges,{'type':'diac'})
      sync_edges_limits = getLimits('weight',edges,{'type':'sync'})
      nodes_size_limits = getLimits('size',nodes) 

      // scales

      nodesScale = d3.scaleLog(nodes_size_limits,[5, 20]);
      chronoSyncEdgesScale = d3.scaleLinear(sync_edges_limits,[1, 7]);
      talesEdgesScale = d3.scaleLinear(diac_edges_limits,[4,8]);   

      // prepare the elements to be drawn

      let prev = 0, cpt = 0;
      let periods_blocks_vectors = {};      

      setupReadingDirection()  

      periods.forEach((period) => {
        
        let blocks = nodes.findRows(period, 'phase'); 
        let diac_edges = raw_diac_edges.filter((row) => period == row.get('phase'));
        let sync_edges = raw_sync_edges.filter((row) => period == row.get('phase'));
      
        // setup the chrono chart sync_edges
        sync_edges.sort(function (e1,e2) {return parseInt(e1.get('weight')) - parseInt(e2.get('weight'));})
        sync_edges.forEach((edge) => {
          let s = (nodes.findRows(period, 'phase'))
                    .find((row) => row.get('id') == edge.get('source'))
          let t = (nodes.findRows(period, 'phase'))
                    .find((row) => row.get('id') == edge.get('target'))
          let weight = parseInt(edge.get('weight'));
          if (s != undefined && t != undefined && s != t && weight > 0) { 
            if (realm == "seman") {
              chronoSyncEdges_seman.push(new chronoSyncEdge(period
                                                     ,toXScreen(parseFloat(s.get('x')))
                                                     ,toXScreen(parseFloat(t.get('x')))
                                                     ,toYScreen(parseFloat(s.get('y')))
                                                     ,toYScreen(parseFloat(t.get('y')))
                                                     ,weight))
            } else {
              chronoSyncEdges_socio.push(new chronoSyncEdge(period
                                                     ,toXScreen(parseFloat(s.get('x')))
                                                     ,toXScreen(parseFloat(t.get('x')))
                                                     ,toYScreen(parseFloat(s.get('y')))
                                                     ,toYScreen(parseFloat(t.get('y')))
                                                     ,weight))              
            }
          }
        })

        // setup the chrono chart diac_edges
        diac_edges.sort(function (e1,e2) {return parseInt(e2.get('weight')) - parseInt(e1.get('weight'));})
        diac_edges.forEach((edge) => {
          let s = nodes.findRow(edge.get('source'),'id')
          let t = nodes.findRow(edge.get('target'),'id') 
          if (s != undefined && t != undefined && s != t) {
            let tale = parseInt(edge.get('sync_component'))
            let diac_edge = new taleEdge(toXScreen(parseFloat(s.get('x')))
                                        ,toXScreen(parseFloat(t.get('x')))
                                        ,toYScreen(parseFloat(s.get('y')))
                                        ,toYScreen(parseFloat(t.get('y')))
                                        ,parseFloat(edge.get('weight'))
                                        ,tale
                                        ,talesColorScale((tale % 12)))
            if (realm == "seman") {
              if (tale in talesEdges_seman) {
                talesEdges_seman[tale].push(diac_edge)
              } else {
                talesEdges_seman[tale] = [diac_edge]
              }
            } else {
              if (tale in talesEdges_socio) {
                talesEdges_socio[tale].push(diac_edge)
              } else {
                talesEdges_socio[tale] = [diac_edge]
              }              
            }
          }
        })

        let blocks_lineage = 0
        let blocks_vectors = {}

        // setup the chronoNodes
        blocks.forEach((block) => {
          let x_screen = toXScreen(parseFloat(block.get('x')));
          let y_screen = toYScreen(parseFloat(block.get('y')));
          let node_id = block.get('id')
          let node_weight = parseInt(block.get('size'));
          let node_meta = block.get('meta')
          let tale = parseInt(block.get('diac_component'));
          let sources = [...new Set((block.get('source')).split('|&|'))]
          let targets = [...new Set((block.get('target')).split('|&|'))]
          if (realm == "seman") {
            sources.forEach((source) => {
              if (source in seman_to_chronoNodes_seman) {
                seman_to_chronoNodes_seman[source].push(node_id)
              } else {
                seman_to_chronoNodes_seman[source] = [node_id]
              }
            })
            chronoNodes_seman[node_id] = new chronoNode(node_id,x_screen,y_screen,node_weight,tale,node_meta,y0_seman,"seman",targets,sources)
          } else {
            sources.forEach((source) => {
              if (source in socio_to_chronoNodes_socio) {
                socio_to_chronoNodes_socio[source].push(node_id)
              } else {
                socio_to_chronoNodes_socio[source] = [node_id]
              }
            })           
            chronoNodes_socio[node_id] = new chronoNode(node_id,x_screen,y_screen,node_weight,tale,node_meta,y0_socio,"socio",targets,sources)
          }

          // for drawing the tales

          let diac_node = new nodeTale(x_screen,y_screen,node_weight,tale,talesColorScale((tale % 12)))
          if (realm == "seman") {
            if (tale in talesNodes_seman) {
              talesNodes_seman[tale].push(diac_node)
            } else {
              talesNodes_seman[tale] = [diac_node]
            }            
          } else {
            if (tale in talesNodes_socio) {
              talesNodes_socio[tale].push(diac_node)
            } else {
              talesNodes_socio[tale] = [diac_node]
            }             
          }


          // for drawing the canopy hull

          let node_hull = parseInt(block.get('sync_component'));
          let node_vector = createVector(toXScreen(parseFloat(block.get('x'))),toYScreen(parseFloat(block.get('y'))));
          if (blocks_vectors[node_hull] !== undefined) {
            blocks_vectors[node_hull].push(node_vector)
          } else {
            blocks_vectors[node_hull] = [node_vector]
          }
        })  

        // setup the canopy
        if (realm == "seman") {
          canopyHulls_seman[period] = [] 
          Object.values(blocks_vectors).forEach((points) => {
            canopyHulls_seman[period].push(new canopyHull(period,points))
          })          
        } else {
          canopyHulls_socio[period] = [] 
          Object.values(blocks_vectors).forEach((points) => {
            canopyHulls_socio[period].push(new canopyHull(period,points))
          })            
        }             
 
        prev = period;
        cpt ++;

      })              

    }
    
    function setup() {

      // canvas
      
      mainCanvas = createCanvas(w,h)
      mainCanvas.parent("p5canvas")

      socioCanvas = [createGraphics(w,h_socio),createGraphics(w,h_socio)]
      timeCanvas = createGraphics(w,h_time)
      semanCanvas = [createGraphics(w,h_seman),createGraphics(w,h_seman)]

      // periods

      periods = nodes_seman.getColumn('phase')
      periods = Array.from(new Set(periods))
      periods.sort()

      xFlowScale = d3.scaleBand(([-1].concat(periods)), [0, w])
      let dx_timeScale = xFlowScale(periods[1]) - xFlowScale(periods[0])

      setupChronoElements("seman",nodes_seman,edges_seman)  
      setupChronoElements("socio",nodes_socio,edges_socio)  

      // meta data
      
      let metalegend = document.getElementById("metalegend")
      let meta_domain = nodes_seman.getColumn('meta')
      meta_domain = Array.from(new Set(meta_domain))
      meta_domain.sort(function (a,b) {return a-b;})
      metaColorScale = d3.scaleOrdinal(meta_domain, ["#0072b2","#e69f00","#56b4e9","#009e73","#f0e442"])
      meta_domain.forEach((meta) => {
        if (meta != "") {
          metalegend.innerHTML += `<p><i class="fa-solid fa-circle" style="color:` 
                               + metaColorScale(meta) + `;"></i> ` 
                               + meta + `</p>`;
        }
      })

      chronoSyncEdges_seman.sort((a,b) => a.getWeight() - b.getWeight())
      chronoSyncEdges_socio.sort((a,b) => a.getWeight() - b.getWeight())
    }    

    function drawTimeLine(canvas,height) {
      canvas.background(255)
      cpt = 0
      periods.forEach((period) => {
        canvas.push()
        canvas.textAlign(CENTER)
        canvas.textSize(16);
        canvas.textFont(neuekabel);
        if (periods[focus] == period) {
          canvas.textFont(neuekabelbold);
        }
        canvas.text(period,xFlowScale(period),height/2 + 5);
        canvas.pop()
        cpt ++;   
      })
    }   

    function drawChronoView(realm,canvas) {
      
      let background_color = color(((shader == "night") ? '#505966' : '#eeeeee'));
      canvas[0].background(background_color);

      /* Steps nodes and edges */
      
      periods.forEach((period) => {

          // draw from past to present
          if (periods.indexOf(period) != focus) {
            
            // draw sync_edges 
            if (displayEdges) {
              if (realm == "seman") {
                chronoSyncEdges_seman.forEach((edge) => {
                  if (edge.getPeriod() == period) {
                      edge.displayEdge(canvas[0],"sync_edge_step")
                  }
                })                
              } else {
                chronoSyncEdges_socio.forEach((edge) => {
                  if (edge.getPeriod() == period) {
                      edge.displayEdge(canvas[0],"sync_edge_step")
                  }
                })                
              }
              
            }

            // draw nodes
            if (realm == "seman") {
              Object.values(chronoNodes_seman).forEach((node) => {
                if ((node.getPeriod() == period)) {
                  if (currentTale < 0) {
                    node.display(canvas[0],"node_step")
                  } else if ((node.getTale() != currentTale)) {
                    node.display(canvas[0],"node_step")
                  }
                }
              })              
            } else {
              Object.values(chronoNodes_socio).forEach((node) => {
                if ((node.getPeriod() == period)) {
                  if (currentTale < 0) {
                    node.display(canvas[0],"node_step")
                  } else if ((node.getTale() != currentTale)) {
                    node.display(canvas[0],"node_step")
                  }
                }
              })              
            }
          }
      })   

      /* Focused nodes and edges */

      // sync_edges
      if (displayEdges) {
        if (realm == "seman") {
          chronoSyncEdges_seman.forEach((edge) => {
            if (edge.getPeriod() == periods[focus]) {
                edge.displayStroke(canvas[0])
            }
          })  
          chronoSyncEdges_seman.forEach((edge) => {
            if (edge.getPeriod() == periods[focus]) {
                edge.displayEdge(canvas[0],"sync_edge_focus")
            }
          })          
        } else {
          chronoSyncEdges_socio.forEach((edge) => {
            if (edge.getPeriod() == periods[focus]) {
                edge.displayStroke(canvas[0])
            }
          })  
          chronoSyncEdges_socio.forEach((edge) => {
            if (edge.getPeriod() == periods[focus]) {
                edge.displayEdge(canvas[0],"sync_edge_focus")
            }
          })          
        }        
        
      }

      // chronoNodes

      if (realm == "seman") {
        Object.values(chronoNodes_seman).forEach((node) => {
          if ((node.getPeriod() == periods[focus]) && (node.getTale() != currentTale)) {
            node.display(canvas[0],"node_focus")
          }
        })        
      } else {
        Object.values(chronoNodes_socio).forEach((node) => {
          if ((node.getPeriod() == periods[focus]) && (node.getTale() != currentTale)) {
            node.display(canvas[0],"node_focus")
          }
        })        
      }
 

      /* Canopy */
      
      if (displayCanopy) {
        background_color = color(((shader == "night") ? '#33363C' : '#eeeeee'));
        background_color.setAlpha(130);
        canvas[1].background(background_color);
        if (realm == "seman") {
          canopyHulls_seman[periods[focus]].forEach((hull) => {
            hull.display(canvas[1])
          })
        } else {
          canopyHulls_socio[periods[focus]].forEach((hull) => {
            hull.display(canvas[1])
          })          
        }
      }

      /* Socio-seman focus */

      if (displayTales) {
        // semantic tales

        if (realm == "seman") {
          let diac_edges = flatten(Object.values(talesEdges_seman))
          diac_edges.forEach((diac_edge) => {
            diac_edge.displayStroke(canvas[1])
          })
          diac_edges.forEach((diac_edge) => {
            diac_edge.displayEdge(canvas[1])
          })
          let diac_nodes = flatten(Object.values(talesNodes_seman))
          diac_nodes.forEach((diac_node) => {
            if(diac_node.getTale() >= 0) {
              diac_node.display(canvas[1])
            }
          }) 

          Object.values(chronoNodes_seman).forEach((node) => {
            if (node.getTale() == currentTale) {
              if (node.getPeriod() == periods[focus]) {
                node.display(canvas[1],"node_focus")  
              } else {
                node.display(canvas[1],"node_step")
              }
            } else if (displayTales && (node.getTale() >= 0)) {
              if (node.getPeriod() == periods[focus]) {
                node.display(canvas[1],"node_focus")  
              } else {
                node.display(canvas[1],"node_step")
              }          
            }
          })                    
        }

        // socio tales  

        if (realm == "socio") {
          let diac_edges = flatten(Object.values(talesEdges_socio))
          diac_edges.forEach((diac_edge) => {
            diac_edge.displayStroke(canvas[1])
          })
          diac_edges.forEach((diac_edge) => {
            diac_edge.displayEdge(canvas[1])
          })
          let diac_nodes = flatten(Object.values(talesNodes_socio))
          diac_nodes.forEach((diac_node) => {
            if(diac_node.getTale() >= 0) {
              diac_node.display(canvas[1])
            }
          }) 

          Object.values(chronoNodes_socio).forEach((node) => {
            if (node.getTale() == currentTale) {
              if (node.getPeriod() == periods[focus]) {
                node.display(canvas[1],"node_focus")  
              } else {
                node.display(canvas[1],"node_step")
              }
            } else if (displayTales && (node.getTale() >= 0)) {
              if (node.getPeriod() == periods[focus]) {
                node.display(canvas[1],"node_focus")  
              } else {
                node.display(canvas[1],"node_step")
              }          
            }
          })                     
        }                   
      }
    }     

    function draw() {
      semanCanvas[0].clear();
      semanCanvas[1].clear();
      socioCanvas[0].clear();
      socioCanvas[1].clear();      
      drawTimeLine(timeCanvas,h_time);
      drawChronoView("seman",semanCanvas);
      drawChronoView("socio",socioCanvas);      
      image(timeCanvas, 0, y0_time);
      image(semanCanvas[0], 0, y0_seman);
      image(semanCanvas[1], 0, y0_seman);
      image(socioCanvas[0], 0, y0_socio);
      image(socioCanvas[1], 0, y0_socio);      
    }  

    function mergeByAlternating(l1,l2) {
      let merged = l1.reduce((acc,v,i) => {
        return acc.concat(v,l2[i]); 
      }, []);
      if (l1.length > l2.length) {
        merged = merged.filter((v) => v !== undefined)
      } else if (l2.length > l1.length) {
        merged = merged.concat(l2.slice(l1.length))
      }
      return merged;
    }

    function findStep(i,lst,ego) {
        if (lst.length == 0) {
          return ego
        } else if (i >= lst.length) {
          return lst[lst.length - 1]
        } else {
          return lst[i]
        }      
    }
   
  </script>
</html>